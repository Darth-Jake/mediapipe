input_side_packet: "input_sequence_example"
output_stream: "output_text"

node {
  calculator: "StringToSequenceExampleCalculator"
  input_side_packet: "STRING:input_sequence_example"
  output_side_packet: "SEQUENCE_EXAMPLE:parsed_sequence_example"
}

node {
  calculator: "UnpackMediaSequenceCalculator"
  input_side_packet: "SEQUENCE_EXAMPLE:parsed_sequence_example"
  output_side_packet: "DATA_PATH:input_file"
  output_side_packet: "AUDIO_DECODER_OPTIONS:audio_decoder_options"
  node_options: {
    [type.googleapis.com/mediapipe.UnpackMediaSequenceCalculatorOptions]: {
      base_audio_decoder_options {
        audio_stream { stream_index: 0 }
      }
    }
  }
}

node {
  calculator: "AudioDecoderCalculator"
  input_side_packet: "INPUT_FILE_PATH:input_file"
  input_side_packet: "OPTIONS:audio_decoder_options"
  output_stream: "AUDIO:audio"
  output_stream: "AUDIO_HEADER:audio_header"
}

node {
  calculator: "AddHeaderCalculator"
  input_stream: "DATA:audio"
  input_stream: "HEADER:audio_header"
  output_stream: "media_audio"
}

# Always convert the audio to mono.
node {
  calculator: "AverageTimeSeriesAcrossChannelsCalculator"
  input_stream: "media_audio"
  output_stream: "mono_waveform"
}

node {
  calculator: "RationalFactorResampleCalculator"
  input_stream: "mono_waveform"
  output_stream: "resampled_waveform"
  node_options: {
    [type.googleapis.com/mediapipe.RationalFactorResampleCalculatorOptions] {
      target_sample_rate: 16000.0
    }
  }
}
node {
  calculator: "SpectrogramCalculator"
  input_stream: "resampled_waveform"
  output_stream: "spectrogram_squared_magnitude"
  node_options: {
    [type.googleapis.com/mediapipe.SpectrogramCalculatorOptions] {
      frame_duration_seconds: 0.025
      frame_overlap_seconds: 0.015
      output_type: SQUARED_MAGNITUDE
    }
  }
}
node {
  calculator: "MelSpectrumCalculator"
  # MelSpectrumCalculator expects SQUARED_MAGNITUDE input, but its output is in
  # linear magnitude units.
  input_stream: "spectrogram_squared_magnitude"
  output_stream: "mel_spectrum_magnitude"
  node_options: {
    [type.googleapis.com/mediapipe.MelSpectrumCalculatorOptions] {
      # Follow the 'wideband' or '16kHz' speech convention.
      channel_count: 64
      min_frequency_hertz: 125.0
      max_frequency_hertz: 7500.0
    }
  }
}
node {
  calculator: "StabilizedLogCalculator"
  input_stream: "mel_spectrum_magnitude"
  output_stream: "log_mel_spectrum_magnitude"
  node_options: {
    [type.googleapis.com/mediapipe.StabilizedLogCalculatorOptions] {
      stabilizer: 0.01
    }
  }
}
node {
  calculator: "TimeSeriesFramerCalculator"
  input_stream: "log_mel_spectrum_magnitude"
  output_stream: "log_mel_spectrum_magnitude_with_context"
  node_options: {
    [type.googleapis.com/mediapipe.TimeSeriesFramerCalculatorOptions] {
      frame_duration_seconds: 0.96
      frame_overlap_seconds: -0.04
    }
  }
}


node {
  calculator: "TfLiteConverterCalculator"
  input_stream: "MATRIX:log_mel_spectrum_magnitude_with_context"
  output_stream: "TENSORS:audio_tensors"
  node_options: {
    [type.googleapis.com/mediapipe.MatrixToTensorCalculatorOptions] {
      transpose: true
    }
  }
}

# Runs a TensorFlow  model on CPU that takes an audio tensors and outputs a
# vector of tensors representing the audio event
node {
  calculator: "TfLiteInferenceCalculator"
  input_stream: "TENSORS:audio_tensors"
  output_stream: "TENSORS:prediction_tensor"
  node_options: {
    [type.googleapis.com/mediapipe.TfLiteInferenceCalculatorOptions] {
      model_path: "mediapipe/models/audio_classification_model/yamnet1_audio_classification.tflite"
    }
  }
}

node {
  calculator: "TfLiteTensorsToFloatsCalculator"
  input_stream: "TENSORS:prediction_tensor"
  output_stream: "FLOATS:prediction_vector"
}

node {
  calculator: "TopKScoresCalculator"
  input_stream: "SCORES:prediction_vector"
  output_stream: "TOP_K_LABELS:output_text"
  node_options: {
    [type.googleapis.com/mediapipe.TopKScoresCalculatorOptions]: {
      top_k: 1
      label_map_path: "mediapipe/graphs/audio_classification/yamnet1_audio_classification_labelmap.txt"
    }
  }
}
